[luv2code]

Hibernate Configuration file (hibernate.cfg.xml)
    Configure info needed by Hibernate
        JDBC
    Read by SessionFactory

ORM, Object Relational Mapping
    Concept : Map an Class to Database table
        Map class to db table : @Entity, @Table
        Map fields to db columns : @Id, @Column
    Anotation mapping
        @Entity
        @Table(name = "student")
        public class Student {
            @Id
            @Column(name = "PRIMARYKEYNAME")
            private int id;

            @Column(name = "first_name")
            private String firstName;

            @Column(name = "last_name")
            private String lastName;

            @Column(name = "email")
            private String email;
        }

Primary Key
    Default : Let DB handle the generation automatically
    @GeneratedValue(strategy) : assign primary key generation strategy
        strategy=GenerationType.AUTO : let db choose
        IDENTITY : MySQL (AUTO_INCREMENT)
        SEQUENCE : Oracle
        TABLE : ...
    Can make costume generation strategy, but not recommended
        unique value, high-volume/multi-thread, server clusters

Hibernate Session & Transaction
    Concept
        Session
            Wrapper outside JDBC connection, does all the low lv database work
            Object that is used to save&retrieve ORM objects from Database
            Retieved from SessionFactory, short lived
        SessionFactory
            Creates Session objects according to the hibernate configuration file
            Is heavy-weight, only create once per application
        Transaction
            Do CRUD within transaction
            Rollback?
    Setup
        1. Prepare SessionFactory, Session
        2. Transaction
            Start transaction -> do transaction(CRUD) -> commit transaction
        3. Code
            SessionFactory factory = new Configuration()
                    .configure("hibernate.cfg.xml")
                    .addAnnotatedClass(Student.class)
                    .buildSessionFactory();
            Session session = factory.getCurrentSession();
            Student tempStudent = new Student("Paul", "Wall", "paul@luv2code.com");
            session.beginTransaction();
            session.save(tempStudent);
            session.getTransaction().commit();

Hibernate C.R.U.D.
    Concept
        Create, read, update, delete objects from/to database
    C.R.U.D.
        Create objects : Create(save/commit) Java object to database with Hibernate
            session.save(ORMEntityInstance);
        Read objects : Retrieve(read) Java object from database with Hibernate
            session.get(ORMEntityClass, PrimaryKey);
        Update objects : Update Java object to database with Hibernate
            ORMEntityInstance.setMethod();
        Delete objects : Delete Java object from database with Hibernate
            session.delete(ORMEntityInstance);
    Commit
        After session command, data manipulation is done in memory
        After commit()
            data is updated to database
            for new data manipulation must renew session

HQL : Hibernate Query Language
    Concept
        similar syntax to SQL but using Java notations, Class for table, fields for columns
    C.R.U.D.
        Create objects
        Read objects
            hql = "from Student";
            hql = "from Student s where s.lastName='Doe'";
            hql = "from Student where lastName='Doe' OR firstName='Daffy'"
            hql = "from Student where email LIKE '%luv2code.com'"
            session.createQuery(hql).list();
        Update objects
            hql = "update Student set email='foo@gmail.com'";
            session.createQuery(hql).executeUpdate();
        Delete objects
            hql = "delete from Student where id=2";
            session.createQuery(hql).executeUpdate();

[Java Brains]
No Hibernate      vs      With Hibernate
    JDBC configuration    Hibernate configuration
    Model object          Annotations
    Service method        Hibernate API
    Database design       X
    DAO coding            X

Hibernate API
    Create session factory
    Create session from session factory
    Use session to save model objects

Configuration
    hibernate.cfg.xml : xml setup for hibernate
        loaded using configure(), can customize name & path as parameter
        default location : src, path = relative path
        SessionFactory sessionFactory = new Configuration().configure(...).buildSessionFactory();
    Register entity classes : adding entity classes to session factory
        XML : <mapping class="..."/>
        Annotation : addAnnotatedClass(...), can be chained
    DB strategy : sets up how hibernate manages database
        XML : <property name="hbm2ddl.auto"></property> : table is managed by hibernate(auto table creation)
            create : at startup db is reset
            update : db is only updated/changed

Simple Entity mapping
    Overview
        Maps how entity(java object) is mapped to table(db object), entity-table relationship
        Simple entity mapping
        Table customization
    DB object name
        Table : default = class name
            @Entity (name="table_name") : changes entity name, must use changed name in HQL
            @Entity @Table(name="table_name")
        Column : default = field name
            @Column(name = "column_name")
            Can be placed over field or field getter
    Entity field
        Persistent field : @Basic, default, field is persistent and hibernate tracks it
        Transient field : @Transient, hibernate ignores field, used for fields that aren't persistent
        Date field : @Temporal, sets db datetime related data type, default is timestamp
            @Temporal(TemporalType.DATE)
        Field size : @Lob, @Clob @Blob, sets db for large data, auto string number
    Primary key
        Natural key : has more use than just providing unique number, manual management
        Surrogate key : @GeneratedValue, use is only to provide unique number
            auto management of pk by hibernate, ignores manual setting of pk
            AUTO(Default) IDENTITY(MySQL) SEQUENCE(Oracle) TABLE
            @GeneratedValue(strategy=GenerationType.AUTO)

Entity Mapping, Entity with Value Objects
    Overview
        Mapping entity with value objects
        Collection (complex value objects)
        Proxy object & Fetch type
    Value object
        Concept
            Entity object : has own meaning, is mapped db table
            Value object : doesn't have own meaning, is always part of Entity object
        Annotation
            Declaration : use either
                @Embeddable : marks class as value object
                @Embedded : marks entity field as value object
            Customization
                @AttributeOverride : overrides default db column name
                    @AttributeOverride(name = "street", column = @Column(name = "HOME_STREET_NAME"))
                @AttributeOverrides : overrides multiple db column names
                    @AttributeOverrides({@AttributeOverride(), ...})
            Primary key
                @Id -> @EmbeddedId
    Collections
        Concept
            Value object where number of parts is unknown
            Can not be mapped to same table of the entity
        Annotation
            Declaration
                @ElementCollection
            Customization
                @JoinTable(name = "USER_ADDRESS", joinColumns = @JoinColumn(name = "USER_ID"))
            Primary key
                @GenericGenerator : depends on type of database, "hilo" not used
                    @GenericGenerator(name="sequence-gen",strategy="sequence")
                @CollectionId(columns = {@Column(name = "ADDRESS_ID")}
                        , type = @Type(type = "long")
                        , generator = "sequence-gen"
                )
    Proxy object & Fetch type
        Proxy object
        Fetch strategy
            Lazy : default, load data from db when needed/uses
                useful if entity have members with large sub structure
            Eager : load all data on entity initialization
        Annotation
            @ElementCollection(fetch = FetchType.EAGER)

Entity Mapping, Entity with entities
    One to One mapping
        Concept
            Entity within entity
        Annotation
            Declaration
                @OneToOne
            Customization
                @JoinColumn(name = "VEHICLE_ID")
    One to Many, Many to One mapping
        Annotation
            Declaration
                @OneToMany
                @ManyToOne
            Customization
                @OneToMany @JoinTable(
                        name = "USER_VEHICLE"
                        , joinColumns = @JoinColumn(name = "USER_ID")
                        , inverseJoinColumns = @JoinColumn(name = "VEHICLE_ID")
                )
                @OneToMany(mappedBy = "user")
                @ManyToOne @JoinColumn(name = "USER_ID")
    Many to Many mapping
        table duplication
        Annotation
            Declaration
                @ManyToMany
            Customization
                @JoinTable(
                    name = "USER_VEHICLE"
                    , joinColumns = @JoinColumn(name = "USER_ID")
                    , inverseJoinColumns = @JoinColumn(name = "VEHICLE_ID")
                )
    Legacy Data
        @NotFound(action = NotFoundAction.IGNORE)
    Cascade
        Saving/persist strategy of entities with entity members, ALL DETACH MERGE PERSIST REFRESH REMOVE
            Persist : when an entity is saved all sub entities are automatically saved
            All : when an entity is changed so are all the sub entities
        @OneToMany(cascade = CascadeType.PERSIST)


[IntelliJ]
Class hierarchy : ctrl + h